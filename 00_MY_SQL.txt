executing one command multiple time can give errors

CREATE DATABASE if not exists name;    #create database if not exists
DROP DATABASE if exists name;      #delete database
USE name;                #use database

CREATE TABLE table_name (column1 datatype, column2 datatype, ...);  #create table

SQL Data Types (numeric datatypes):
Signed datatype (-128-127)- INT, SMALLINT, MEDIUMINT, BIGINT, TINYINT, YEAR
Unsigned datatype (0-255)- INT UNSIGNED, SMALLINT UNSIGNED, MEDIUMINT UNSIGNED, BIGINT UNSIGNED, TINYINT UNSIGNED

<----------------------SQL commands---------------------->

DDL (Data Definition Language) - CREATE, ALTER, DROP, TRUNCATE, RENAME
DML (Data Manipulation Language) - INSERT, UPDATE, DELETE, MERGE, CALL, EXPLAIN PLAN, LOCK TABLE
DCL (Data Control Language) - GRANT, REVOKE
TCL (Transaction Control Language) - COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION
DQL (Data Query Language) - SELECT

<----------------------SAFE MODE---------------------->

SET SQL_SAFE_UPDATES = 0;  #to disable safe mode
safe mode is used to prevent sql injection

<----------------------show command---------------------->
show databases;
show tables;
show columns from table_name;

<----------------------basic sql commands---------------------->
SELECT * FROM table_name;     #select all columns from table
SELECT column1, column2 FROM table_name;   #select specific columns from table

INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);  #insert values into table
INSERT INTO table_name VALUES (value1, value2, ...);  #insert values into table

UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;  #update values in table

PRIMARY KEY - It is a column in table that uniquely identifies each row in the table. It is used to ensure that no two rows in the table have the same value for this column. (like index numbers or a unique id)
FOREIGN KEY - It is a column in table that references a primary key in another table. It is used to establish a relationship between tables.


<----------------------Constraints---------------------->

NOT NULL - This constraint prevents null values from being inserted into the column.
UNIQUE - This constraint prevents duplicate values from being inserted into the column.
PRIMARY KEY - This constraint makes the column a primary key, which is a unique identifier for each row in the table.  

we can make PRIMARY KEY with multiple values like 
    PRIMARY KEY(id,name) it means the combination wont be copied
 
FOREIGN KEY - This constraint makes the column a foreign key, which is a reference to a primary key in another table. 
    FOREIGN KEY (column_name) REFERENCES table_name (column_name)

DEFAULT it will set the default value for the column if no value is provided when inserting a new row into the table. 
    salary INT DEFAULT 50000;

CONSTRAINTS - it limits the values that allowd into the column.

SELECT DISTINCT column_name FROM table_name;  #select unique values from column that are not repeated

<----------------------Aggregates---------------------->

WHERE  - it is used to filter rows based on a condition.
ORDER BY - it is used to sort rows based on one or more columns.
GROUP BY - it is used to group rows based on one or more columns.
HAVING - it is used to filter groups based on a condition.
LIMIT - it is used to limit the number of rows returned.

<-------- WHERE CLAUSE -------->
SELECT column_name(s) FROM table_name WHERE condition;
SELECT * FROM employees WHERE age > 30 AND salary > 50000;            #select all employees older than 30 years and with a salary greater than 50000
we can use all operators in where clause like =, !=, >, <, >=, <=, LIKE, IN, BETWEEN, IS NULL, IS NOT NULL, AND, OR, NOT, EXISTS, ANY, ALL, SOME, EVERY, MATCH, CONTAINS, STARTSWITH, ENDSWITH, CONTAINSKEYWORD

<-------- ORDER BY CLAUSE -------->
SELECT column_name(s) FROM table_name ORDER BY column_name ASC;   #sort in ascending order
SELECT column_name(s) FROM table_name ORDER BY column_name DESC;  #sort in descending order

<-------- LIMIT CLAUSE -------->
SELECT column_name(s) FROM table_name LIMIT n;  #select the first n rows
SELECT column_name(s) FROM table_name LIMIT n OFFSET m;  #select the first n rows starting from the mth row

            SELECT → FROM → WHERE → ORDER BY → LIMIT

AGGREGATE FUNCTIONS - its like inbuilt FUNCTIONS
COUNT, SUM, AVG, MIN, MAX, GROUP BY
SELECT COUNT(column_name) FROM table_name;
SELECT SUM(column_name) FROM table_name;
SELECT AVG(column_name) FROM table_name;

<----------------------GROUP BY CLAUSE---------------------->

SELECT column_name(s) FROM table_name GROUP BY column_name;   


<----------------------HAVING CLAUSE---------------------->

SELECT column_name(s) FROM table_name GROUP BY column_name HAVING condition;

SELECT column_name(s) 
FROM table_name 
WHERE condition                         - it will filter the rows
GROUP BY column_name 
HAVING condition;                       - it will filter the groups
ORDER BY column_name ASC;               - it will sort the rows

<----------------------TABLE RELATED QUERIES---------------------->
UPDATE table_name 
SET column1 = value1, column2 = value2, ... 
WHERE condition;  #update values in table 

DELETE FROM table_name WHERE condition;  #delete rows from table    

<----------------------CASCADING FOR FOREIGN KEY---------------------->

Cascading actions automatically perform operations on related records when the parent record is modified or deleted.
(1)ON DELETE CASCADE - This action deletes the related records when the parent record is deleted.
(2)ON UPDATE CASCADE - This action updates the related records when the parent record is updated.

CREATE TABLE table_name (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    FOREIGN KEY (id) REFERENCES table_name(id)
);

CREATE TABLE table_name (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    FOREIGN KEY (id) REFERENCES table_name(id) 
    ON DELETE CASCADE
    ON UPDATE CASCADE
)



<-------------------------ALTER COMMAND------------------------->
its use to modify the structure of a table by adding or deleting columns 

ALTER TABLE table_name ADD COLUMN column_name datatype;
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name MODIFY COLUMN column_name datatype;

ALTER TABLE RENAME table_name TO new_table_name;

CHANGE column - ALTER TABLE table_name CHANGE old_name column_name new_column_name datatype;
MODIFY column - ALTER TABLE table_name MODIFY column_name new_datatype new_constraint;

<-------------------------CASE EXPRESSIONS------------------------->

UPDATE table_name                                       UPDATE dept
SET column_name = CASE                                  SET difficulty = CASE id
    WHEN condition1 THEN value1                         when id = 1 then easy
    WHEN condition2 THEN value2                         when id = 2 then medium
    ELSE value3                                         else hard
END                                                     END
WHERE condition;                                        WHERE(1,2)

<-------------------------VIEW------------------------->

CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition;
CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition GROUP BY column_name(s);

it will create a virtual table that is a copy of the data from another table

<-------------------------TRUNCATE TABLE------------------------->
TRUNCATE TABLE table_name;   #it will delete all the rows from the table but keep the structure of the table

<------------------------------------JOINS---------------------------------------->

INNER JOIN - This type of join returns only the rows that have matching values in both tables.

SLECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;

LEFT JOIN - This type of join returns all the rows from the left table and only the matching rows from the right table.

SLECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;

RIGHT JOIN - This type of join returns all the rows from the right table and only the matching rows from the left table.

SLECT column_name(s)
FROM table1
RIGHT JOIN table2    
ON table1.column_name = table2.column_name;

FULL JOIN - This type of join returns all the rows from both tables, regardless of whether there is a match or not.

SLECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name
UNION
SLECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;

LEFT EXCLUSIVE JOIN - This type of join returns all the rows from the left table and only the non-matching rows from the right table.

SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name
WHERE table2.column_name IS NULL;

<------------------------------------ALIASES---------------------------------------->

ALIASES - it is used to give a table or column a temporary name.

SELECT column_name(s) FROM table_name AS table_alias;
SELECT column_name(s) FROM table_name table_alias;  



| Task                                                   | SQL Window Feature                          |
| ------------------------------------------------------ | ------------------------------------------- |
| Find top 3 performing employees every month            | `RANK()` or `DENSE_RANK()`                  |
| Calculate running total of sales                       | `SUM() OVER()`                              |
| Compare each employee’s salary with department average | `AVG() OVER(PARTITION BY dept)`             |
| Find moving average of revenue                         | `AVG() OVER(ORDER BY date ROWS BETWEEN...)` |
| Show % contribution of each sale to total              | `SUM(amount) OVER()`                        |
